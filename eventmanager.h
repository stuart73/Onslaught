// Event_manager.h: interface for the Event_manager class.
//
//////////////////////////////////////////////////////////////////////

#ifndef EVENT_MANAGER_INCLUDE
#define EVENT_MANAGER_INCLUDE


#include "OPtrSet.h"
#include "Event.h"
#include "scheduledevent.h"


#define NEXT_FRAME -1.0
#define START_OF_FRAME 0
#define MIDDLE_OF_FRAME 1
#define END_OF_FRAME 2


#define MAX_NUM_EVENTS 20000


#define NUM_PRIORITY 3 
#define NUM_EVENT_LIST_BUFFERS 200 // 10 seconds worth of buffer ( 200 / 20 fps ) 
// (i.e. events can be stored in any frame from mTime + 10 seconds)


/*  Event Manager stores and executes all the events generated by the game code.
	To speed things up (i.e. don't store all events in one big linked list) there
	are event list buffers.  Each buffer stores one frames worth of events (i.e. 
	all the events which are to executed at the same time).  When adding an event the 
	event manager quickly decides which buffer to place the event into.  If the event 
	is to be executed outside the buffer range, it is added to an overflow event 
	buffer instead.  The buffer system uses a rap-around type method, so when buffer
	200 is reached it loops back to buffer 0 etc 
*/

// NOTE:  There is a restriction at the mo where any event which gets placed in the
//        overflow buffer defaults to END_OF_FRAME priority, as all the events in the
//        normal event list buffer will get executed before it checks if any events
//        need executing in the overflow buffer.

class CEventManager
{
public:
					CEventManager();
	virtual			~CEventManager();

	void			Init();
	void			Shutdown();
	void			Update() ;  // does a 'AdvanceTime' then a 'Flush'

	void			AdvanceTime() ;
	void			Flush();
	void			AddEvent(const int event_num, CMonitor* to_call, const float& time, const int start_or_end  = START_OF_FRAME, CMonitor* data = NULL, CScheduledEvent* re_use_event = NULL);
	void			AddEvent(const float& time_from_now, const int event_num, CMonitor* to_call, const int start_or_end = START_OF_FRAME, CMonitor* data = NULL, CScheduledEvent* re_use_event = NULL);
	void			AddEvent(CScheduledEvent* event) ;
	const int		TotalEvents() { return mNumEventsInEventManager ; }
	ULONG			GetNumEventsProcessedInLastUpdate() { return mEventsProcessedThisUpdate ; }
	const float&	GetTime() { return mTime; }
	ULONG			GetCurrentEventProcessNum() { return mTotalEventProcessedNum ; }
	ULONG			GetFrameCount() { return mFrameCount ; }

	// debug stuff
	void			LogEvent(CScheduledEvent* event);
	void			LogEventManager() ;
	CScheduledEvent* GetNextFreeEvent() ;
	BOOL			IsValid() { return mValid ; }

private:

	BOOL	mValid;	
	void	FreeEvent(CScheduledEvent* event);
    float	mTime; // curent time since last reset
	ULONG	mTotalEventProcessedNum ; // each event which is executed has a unique number to it
	int     mCurrentBufferNum; // which buffer to add events to next
	ULONG	mFrameCount ;    // number of frames which have passed since reset
	int		mNumEventsInEventManager ; 
	int     mReadyToFlushBuffer ;
	ULONG   mEventsProcessedThisUpdate; // number of events process per update
	int		mCurrentProcessOverflowEventNum ;
	CScheduledEvent*	mEventFreeList;
	CScheduledEvent*	mEventsPool;

	// buffers
	SPtrSet<CScheduledEvent> mEventListBuffer[NUM_EVENT_LIST_BUFFERS][NUM_PRIORITY];
	OPtrSet<CScheduledEvent>* mOverflowEventListBuffer;
};

extern CEventManager EVENT_MANAGER ;


#endif 
